/* $Revision: 1.3 $ */
// Automatically generated by MATLAB Project Wizard version 1.0

//
// This is the gateway routine for a MATLAB Math/Graphics Library-based
// C MATLAB MEX File.

#include "mex.h"
#include "math.h"

double** AlocaMatrixDoubleZerada(int n_lin, int n_col);
int** AlocaMatrixIntZerada(int n_lin, int n_col);
double** CriaMatrizDistancias(double **contorno, int n_lin);
void AplicaLimiar(double **mat_dist, int **mat_limiar, int n_lin, double limiar, int zerar_abaixo);
void CalculaGrau(int **mat_limiar, int **mat_grau, int n_lin, int indice);
void CalculaJointDegree(int **mat_limiar, double **mat_jd, int **mat_grau, int n_lin, int indice);
void CalculaCoefClustering(int **mat_limiar, double **mat_coef_cluster, int n_lin, int indice);
void CopiaMatrizIntPonteiroMatlab(int **mat, double *pr, int n_lin, int n_col);
void CopiaMatrizDoublePonteiroMatlab(double **mat, double *pr, int n_lin, int n_col);

void mexFunction(
	int nlhs,              // Number of left hand side (output) arguments
	mxArray *plhs[],       // Array of left hand side arguments
	int nrhs,              // Number of right hand side (input) arguments
	const mxArray *prhs[]  // Array of right hand side arguments
)
{

	double *pr, *limiar, **contorno, **distancias, **jd, **coef_cluster;
	double *pr_grau, *pr_jd, *pr_coef_cluster;
	int **mat_limiar, nro_saidas, **grau;	
	int cont, nro_lin, nro_col, nro_limiar, zerar_abaixo, li;
	
    /* check number of parameters */
    if (nrhs != 3) {
       mexErrMsgTxt("RCAssinForma_MEX requires three input argument.");
    } else if (nlhs > 3) {
       mexErrMsgTxt("RCAssinForma_MEX requires maximum three output arguments.");
    }

	nro_saidas = nlhs;
    nro_lin = mxGetM(prhs[0]);    /* nro linhas do contorno */
    nro_col = mxGetN(prhs[0]);    /* nro colunas do contorno */      
    pr = mxGetPr(prhs[0]);

    nro_limiar = mxGetNumberOfElements(prhs[1]); //tamanho do vetor de limiares...   
    limiar = mxGetPr(prhs[1]);//set os ponteiros dos limiares...
 
    zerar_abaixo = (int) mxGetScalar(prhs[2]); //1: zerar abaixo; 0: zerar acima...
	
    contorno = (double **) malloc (nro_col * sizeof(double *));
    for (cont = 0; cont < nro_col; cont++){
 	   contorno[cont] = pr + cont*nro_lin;
    }

	distancias = CriaMatrizDistancias(contorno,nro_lin);//cria matriz distanicas
	mat_limiar = AlocaMatrixIntZerada(nro_lin,nro_lin);//aloca a matriz de limiares...
	grau = AlocaMatrixIntZerada(nro_limiar,nro_lin);//aloca a matriz de grau...
	
	if (nro_saidas > 1){
		jd = AlocaMatrixDoubleZerada(nro_limiar,nro_lin);//aloca a matriz de jointdegree...
	}

	if (nro_saidas > 2){
		coef_cluster = AlocaMatrixDoubleZerada(nro_limiar,nro_lin);//aloca a matriz de coef clustering...
	}

	for (li = 0; li < nro_limiar; li++){
		AplicaLimiar(distancias, mat_limiar, nro_lin, limiar[li], zerar_abaixo);//aplica limiar a matriz de distancias...
		CalculaGrau(mat_limiar,grau,nro_lin,li);
		if (nro_saidas > 1){
			CalculaJointDegree(mat_limiar,jd,grau,nro_lin,li);
		}

		if (nro_saidas > 2){
			CalculaCoefClustering(mat_limiar,coef_cluster,nro_lin,li);
		}
	}

	//zerar matrizes que não são mais utilizadas...
	for (li = 0; li < nro_lin; li++){
		free(distancias[li]);
		free(mat_limiar[li]);
	}
	
	free(distancias);
	free(mat_limiar);
	
	plhs[0] = mxCreateDoubleMatrix(nro_limiar,nro_lin,mxREAL);   
	pr_grau = (double *) mxGetPr(plhs[0]);
	CopiaMatrizIntPonteiroMatlab(grau, pr_grau, nro_limiar, nro_lin);
	//zera matriz de grau
	for (li = 0; li < nro_limiar; li++){
		free(grau[li]);
	}	
	free(grau);

	if (nro_saidas > 1){
		plhs[1] = mxCreateDoubleMatrix(nro_limiar,nro_lin,mxREAL);   
		pr_jd = (double *) mxGetPr(plhs[1]);
		CopiaMatrizDoublePonteiroMatlab(jd, pr_jd, nro_limiar, nro_lin);
		//zera matriz de jointdegree
		for (li = 0; li < nro_limiar; li++){
			free(jd[li]);
		}	
		free(jd);
	}

	if (nro_saidas > 2){
		plhs[2] = mxCreateDoubleMatrix(nro_limiar,nro_lin,mxREAL);   
		pr_coef_cluster = (double *) mxGetPr(plhs[2]);
		CopiaMatrizDoublePonteiroMatlab(coef_cluster, pr_coef_cluster, nro_limiar, nro_lin);
		//zera matriz de coef. clustering
		for (li = 0; li < nro_limiar; li++){
			free(coef_cluster[li]);
		}	
		free(coef_cluster);
	}

}

double** AlocaMatrixDoubleZerada(int n_lin, int n_col){
	double **matriz;
	int lin, col;

	matriz = (double **) malloc (n_lin * sizeof(double *));
	for (lin = 0; lin < n_lin; lin++){
		matriz[lin] = (double *) malloc (n_col * sizeof(double));
		for (col = 0; col < n_col; col++){
			matriz[lin][col] = (double) 0;
		}
	}

	return matriz;
}


int** AlocaMatrixIntZerada(int n_lin, int n_col){
	int **matriz;
	int lin, col;

	matriz = (int **) malloc (n_lin * sizeof(int *));
	for (lin = 0; lin < n_lin; lin++){
		matriz[lin] = (int *) malloc (n_col * sizeof(int));
		for (col = 0; col < n_col; col++){
			matriz[lin][col] = 0;
		}
	}

	return matriz;
}

double** CriaMatrizDistancias(double **contorno, int n_lin){
	double ** distancias, maior_dist, dist, d1,d2;
	int lin, col;
	
	distancias = AlocaMatrixDoubleZerada(n_lin, n_lin);
	maior_dist = 0;
	//calcula distancias...
	for (lin = 0; lin < (n_lin - 1); lin++){
		for (col = lin+1; col < n_lin; col++){
			d1 = contorno[0][lin] - contorno[0][col];
			d2 = contorno[1][lin] - contorno[1][col];

			dist = sqrt(d1 * d1 + d2 * d2);
			if (dist > maior_dist){
				maior_dist = dist;
			}

			distancias[lin][col] = dist;
			distancias[col][lin] = dist;
		}
	}

	//normaliza...
	for (lin = 0; lin < (n_lin - 1); lin++){
		for (col = lin+1; col < n_lin; col++){
			dist = distancias[lin][col] / maior_dist;
				
			distancias[lin][col] = dist;
			distancias[col][lin] = dist;
		}
	}

	return distancias;
}

void AplicaLimiar(double **mat_dist, int **mat_limiar, int n_lin, double limiar, int zerar_abaixo){
	int lin, col, maior, menor;

	if (zerar_abaixo == 1){
		maior = 1;
		menor = 0;
	}
	else{
		maior = 0;
		menor = 1;
	}	
	
	//calcula distancias...
	for (lin = 0; lin < (n_lin - 1); lin++){
		for (col = lin+1; col < n_lin; col++){
			if (mat_dist[lin][col] >= limiar){
				mat_limiar[lin][col] = maior;
				mat_limiar[col][lin] = maior;
			}
			else{
				mat_limiar[lin][col] = menor;
				mat_limiar[col][lin] = menor;
			}
		}
	}
}

void CalculaGrau(int **mat_limiar, int **mat_grau, int n_lin, int indice){
	int lin, col;

	//calcula o grau de cada vertice...
	for (lin = 0; lin < (n_lin - 1); lin++){
		for (col = lin+1; col < n_lin; col++){
			if (mat_limiar[lin][col] == 1){
				mat_grau[indice][lin] = mat_grau[indice][lin] + 1;
				mat_grau[indice][col] = mat_grau[indice][col] + 1;
			}
		}
	}
}

void CalculaJointDegree(int **mat_limiar, double **mat_jd, int **mat_grau, int n_lin, int indice){
	int lin, col, total, grau_igual;

	//calcula o joint degree de cada vertice...
	for (lin = 0; lin < n_lin; lin++){
		total = 0;
		grau_igual = 0;

		for (col = 0; col < n_lin; col++){
			if (lin != col){
				if (mat_limiar[lin][col] == 1){
					total++;
					if (mat_grau[indice][lin] == mat_grau[indice][col]){
						grau_igual++;
					}
				}
			}
		}
		
		if (total != 0){
			mat_jd[indice][lin] = (double) grau_igual / total;
		}
	}
}

void CalculaCoefClustering(int **mat_limiar, double **mat_coef_cluster, int n_lin, int indice){
	int lin, col, k, nro_triplas, nro_triangulos;

	//calcula o grau de cada vertice...
	for (lin = 0; lin < n_lin; lin++){
		nro_triplas = 0;
		nro_triangulos = 0;

		for (col = 0; col < n_lin; col++){
			if (mat_limiar[lin][col] == 1){
				for (k = 0; k < n_lin; k++){
					if(k != lin){
						if (mat_limiar[col][k] == 1){
							nro_triplas++;
							if (mat_limiar[k][lin] == 1){
								nro_triangulos++;
							}
						}											
					}
				}//for k...
			}
		}//for col...

		if (nro_triplas == 0){
			mat_coef_cluster[indice][lin] = (double) 0;
		}
		else{
			mat_coef_cluster[indice][lin] = (double) nro_triangulos / nro_triplas;;
		}
	}//for lin...
}

void CopiaMatrizIntPonteiroMatlab(int **mat, double *pr, int n_lin, int n_col){
	int lin, col, cont;

	cont = -1;
	for (col = 0; col < n_col; col++){
		for (lin = 0; lin < n_lin; lin++){
			cont++;
			pr[cont] = mat[lin][col];
		}
	}
}

void CopiaMatrizDoublePonteiroMatlab(double **mat, double *pr, int n_lin, int n_col){
	int lin, col, cont;

	cont = -1;
	for (col = 0; col < n_col; col++){
		for (lin = 0; lin < n_lin; lin++){
			cont++;
			pr[cont] = mat[lin][col];
		}
	}
}